{"version":3,"sources":["../src/train-stream.js"],"names":["TrainStream","opts","objectMode","neuralNetwork","Error","dataFormatDetermined","inputKeys","outputKeys","i","iterations","errorThresh","log","console","logPeriod","callback","callbackPeriod","floodCallback","doneTrainingCallback","size","count","sum","on","finishStreamIteration","bind","write","chunk","enc","next","emit","Array","from","Set","concat","Object","keys","input","output","firstDatum","data","formatData","trainDatum","datum","trainPattern","isArray","inputLookup","lookup","lookupFromArray","outputLookup","verifyIsInitialized","error","Writable"],"mappings":"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","file":"train-stream.js","sourcesContent":["import { Writable } from 'stream';\nimport lookup from './lookup';\n\n/**\n *\n * @param opts\n * @returns {TrainStream}\n * @constructor\n */\nexport default class TrainStream extends Writable {\n  constructor(opts) {\n    super({\n      objectMode: true\n    });\n\n    opts = opts || {};\n\n    // require the neuralNetwork\n    if (!opts.neuralNetwork) {\n      throw new Error('no neural network specified');\n    }\n\n    this.neuralNetwork = opts.neuralNetwork;\n    this.dataFormatDetermined = false;\n\n    this.inputKeys = [];\n    this.outputKeys = []; // keeps track of keys seen\n    this.i = 0; // keep track of the for loop i variable that we got rid of\n    this.iterations = opts.iterations || 20000;\n    this.errorThresh = opts.errorThresh || 0.005;\n    this.log = opts.log ? (typeof opts.log === 'function' ? opts.log : console.log) : false;\n    this.logPeriod = opts.logPeriod || 10;\n    this.callback = opts.callback;\n    this.callbackPeriod = opts.callbackPeriod || 10;\n    this.floodCallback = opts.floodCallback;\n    this.doneTrainingCallback = opts.doneTrainingCallback;\n\n    this.size = 0;\n    this.count = 0;\n\n    this.sum = 0;\n\n    this.on('finish', this.finishStreamIteration.bind(this));\n  }\n\n  endInputs() {\n    this.write(false);\n  }\n\n  /**\n   * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}\n   * @param chunk\n   * @param enc\n   * @param next\n   * @returns {*}\n   * @private\n   */\n  _write(chunk, enc, next) {\n    if (!chunk) {\n      // check for the end of one iteration of the stream\n      this.emit('finish');\n      return next();\n    }\n\n    if (!this.dataFormatDetermined) {\n      this.size++;\n      this.inputKeys = Array.from(new Set(this.inputKeys.concat(Object.keys(chunk.input))));\n      this.outputKeys = Array.from(new Set(this.outputKeys.concat(Object.keys(chunk.output))));\n      this.firstDatum = this.firstDatum || chunk;\n      return next();\n    }\n\n    this.count++;\n\n    const data = this.neuralNetwork.formatData(chunk);\n    this.trainDatum(data[0]);\n\n    // tell the Readable Stream that we are ready for more data\n    next();\n  }\n\n  /**\n   *\n   * @param datum\n   */\n  trainDatum(datum) {\n    this.sum += this.neuralNetwork.trainPattern(datum.input, datum.output, true);\n  }\n\n  /**\n   *\n   * @returns {*}\n   */\n  finishStreamIteration() {\n    if (this.dataFormatDetermined && this.size !== this.count) {\n      this.log('This iteration\\'s data length was different from the first.');\n    }\n\n    if (!this.dataFormatDetermined) {\n      // create the lookup\n      if(!Array.isArray(this.firstDatum.input)) {\n        this.neuralNetwork.inputLookup = lookup.lookupFromArray(this.inputKeys);\n      }\n      if(!Array.isArray(this.firstDatum.output)) {\n        this.neuralNetwork.outputLookup = lookup.lookupFromArray(this.outputKeys);\n      }\n      const data = this.neuralNetwork.formatData(this.firstDatum);\n      this.neuralNetwork.verifyIsInitialized(data);\n      this.dataFormatDetermined = true;\n\n      if (typeof this.floodCallback === 'function') {\n        this.floodCallback();\n      }\n      return;\n    }\n\n    const error = this.sum / this.size;\n\n    if (this.log && (this.i % this.logPeriod === 0)) {\n      this.log('iterations:', this.i, 'training error:', error);\n    }\n    if (this.callback && (this.i % this.callbackPeriod === 0)) {\n      this.callback({\n        error: error,\n        iterations: this.i\n      });\n    }\n\n    this.sum = 0;\n    this.count = 0;\n    // update the iterations\n    this.i++;\n\n    // do a check here to see if we need the stream again\n    if (this.i < this.iterations && error > this.errorThresh) {\n      if (typeof this.floodCallback === 'function') {\n        return this.floodCallback();\n      }\n    } else {\n      // done training\n      if (typeof this.doneTrainingCallback === 'function') {\n        return this.doneTrainingCallback({\n          error: error,\n          iterations: this.i\n        });\n      }\n    }\n  }\n}\n"]}